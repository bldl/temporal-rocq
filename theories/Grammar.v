(* Defines regular "grammars" in terms of regular expressions. *)

From Ltac2 Require Import Ltac2 List Printf.
Set Default Proof Mode "Classic".

From Stdlib Require Import
  Ascii
  List
  Strings.String
  Setoid
  Program.Equality
  ZArith.
From Temporal Require Import StringUtil.
Open Scope string_scope.

(** A regular grammar *)
Inductive grammar :=
| nothing
| empty
| char (c : ascii)
| alternative (a b : grammar)
| sequence (a b : grammar)
| star (a : grammar).

(** `generates g s` is a proposition which states that the string `s` can be
    generated by the grammar `g` *)
Inductive generates : grammar -> string -> Prop :=
| gen_empty : generates empty EmptyString
| gen_char : forall c, generates (char c) (String c EmptyString)
| gen_alt_l : forall s a b, generates a s -> generates (alternative a b) s
| gen_alt_r : forall s a b, generates b s -> generates (alternative a b) s
| gen_seq : forall s0 s1 a b, generates a s0 -> generates b s1 -> generates (sequence a b) (s0 ++ s1)
| gen_star_l : forall a, generates (star a) EmptyString
| gen_star_r : forall s0 s1 a, generates a s0 -> generates (star a) s1 -> generates (star a) (s0 ++ s1).

Fixpoint ntimes (n : nat) (a : grammar) :=
  match n with
  | 0 => empty
  | S n' => sequence a (ntimes n' a)
  end.

Fixpoint seq (gs : list grammar) :=
  match gs with
  | nil => empty
  | g :: gs' => sequence g (seq gs')
  end.

Fixpoint alt (gs : list grammar) :=
  match gs with
  | nil => nothing
  | g :: gs' => alternative g (alt gs')
  end.

Definition maybe a := alternative empty a.

Definition digit : grammar :=
  alt (
    char "0" :: char "1" :: char "2" :: char "3" :: char "4" ::
    char "5" :: char "6" :: char "7" :: char "8" :: char "9" ::
    nil
  ).

Module Grammar.
  (* two grammars are equivalent if they generate the same strings *)
  Definition Equiv (a b : grammar) := forall s, generates a s <-> generates b s.

  Module Equiv.
    Lemma refl : reflexive grammar Equiv.
    Proof.
      unfold reflexive, Equiv.
      split; intros; assumption.
    Qed.

    Lemma symm : symmetric grammar Equiv.
    Proof.
      unfold symmetric, Equiv.
      split; apply H.
    Qed.

    Lemma trans : transitive grammar Equiv.
    Proof.
      unfold transitive, Equiv.
      split.
      - intros. apply H0. apply H. assumption.
      - intros. apply H. apply H0. assumption.
    Qed.

    Add Relation grammar Equiv
      reflexivity proved by refl
      symmetry proved by symm
      transitivity proved by trans
      as Equiv_rel.
  End Equiv.

  Lemma alternative_assoc :
    forall a b c,
    Equiv (alternative (alternative a b) c) (alternative a (alternative b c)).
  Proof.
    split.
    - intros.
      dependent induction H.
      + dependent induction H.
        apply gen_alt_l; assumption.
        apply gen_alt_r, gen_alt_l; assumption.
      + apply gen_alt_r, gen_alt_r; assumption.
    - intros.
      dependent induction H.
      + apply gen_alt_l, gen_alt_l; assumption.
      + dependent induction H.
        apply gen_alt_l, gen_alt_r; assumption.
        apply gen_alt_r; assumption.
  Qed.

  Lemma alternative_comm :
    forall a b, Equiv (alternative a b) (alternative b a).
  Proof.
    split.
    - intros.
      dependent induction H.
      + apply gen_alt_r.
        assumption.
      + apply gen_alt_l.
        assumption.
    - intros.
      dependent induction H.
      + apply gen_alt_r.
        assumption.
      + apply gen_alt_l.
        assumption.
  Qed.

  Lemma alternative_nothing : forall a, Equiv a (alternative a nothing).
  Proof.
    split.
    - intros.
      apply gen_alt_l.
      assumption.
    - intros.
      dependent induction H.
      + assumption.
      + inversion H.
  Qed.

  Lemma sequence_assoc :
    forall a b c,
    Equiv (sequence (sequence a b) c) (sequence a (sequence b c)).
  Proof.
    split.
    - intros.
      dependent induction H.
      dependent induction H.
      rewrite append_assoc.
      apply gen_seq.
      + assumption.
      + apply gen_seq; assumption.
    - intros.
      dependent induction H.
      dependent induction H0.
      rewrite <- append_assoc.
      apply gen_seq.
      + apply gen_seq; assumption.
      + assumption.
  Qed.

  Lemma sequence_empty_l : forall a, Equiv a (sequence empty a).
  Proof.
    split.
    - intros.
      rewrite <- append_empty_l.
      apply gen_seq.
      + constructor.
      + assumption.
    - intros.
      dependent induction H.
      dependent induction H.
      assumption.
  Qed.

  Lemma sequence_empty_r : forall a, Equiv a (sequence a empty).
  Proof.
    split.
    - intros.
      rewrite <- append_empty_r.
      apply gen_seq.
      + assumption.
      + constructor.
    - intros.
      dependent induction H.
      dependent induction H0.
      rewrite append_empty_r.
      assumption.
  Qed.

  Lemma sequence_nothing_l : forall a, Equiv nothing (sequence nothing a).
  Proof.
    split.
    - intros.
      inversion H.
    - intros.
      dependent induction H.
      inversion H.
  Qed.

  Lemma sequence_nothing_r : forall a, Equiv nothing (sequence a nothing).
  Proof.
    split.
    - intros.
      inversion H.
    - intros.
      dependent induction H.
      inversion H0.
  Qed.

  Lemma unfold_star : forall a, Equiv (star a) (maybe (sequence a (star a))).
  Proof.
    split.
    - intros.
      dependent induction H.
      + apply gen_alt_l.
        constructor.
      + apply gen_alt_r.
        apply gen_seq; assumption.
    - intros.
      dependent induction H; dependent induction H.
      + apply gen_star_l.
      + apply gen_star_r; assumption.
  Qed.

  Lemma sequence_alternative_distrib_l :
    forall a b c,
    Equiv (sequence a (alternative b c)) (alternative (sequence a b) (sequence a c)).
  Proof.
    split.
    - intros.
      dependent induction H.
      dependent induction H0.
      + apply gen_alt_l.
        apply gen_seq; assumption.
      + apply gen_alt_r.
        apply gen_seq; assumption.
    - intros.
      dependent induction H; dependent induction H.
      + apply gen_seq.
        assumption.
        apply gen_alt_l.
        assumption.
      + apply gen_seq.
        assumption.
        apply gen_alt_r.
        assumption.
  Qed.

  Lemma sequence_alternative_distrib_r :
    forall a b c,
    Equiv (sequence (alternative a b) c) (alternative (sequence a c) (sequence b c)).
  Proof.
    split.
    - intros.
      dependent induction H.
      dependent induction H.
      + apply gen_alt_l.
        apply gen_seq; assumption.
      + apply gen_alt_r.
        apply gen_seq; assumption.
    - intros.
      dependent induction H; dependent induction H.
      + apply gen_seq.
        apply gen_alt_l.
        assumption.
        assumption.
      + apply gen_seq.
        apply gen_alt_r.
        assumption.
        assumption.
  Qed.

  Lemma equiv_elim {g0 g1 s} :
    generates g0 s -> Equiv g0 g1 -> generates g1 s.
  Proof.
    intros.
    specialize (H0 s).
    apply H0.
    assumption.
  Qed.

  (*Check nat_ind.
  nat_ind
     : forall P : nat -> Prop, P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n

  Lemma ntimes_ind g :
    forall P : grammar -> string -> Prop,
    P (ntimes 0 g) "" ->
    (forall s0 s1 n, P (ntimes n g) s1 -> P g s0 /\ P (ntimes (S n) g) (s0 ++ s1)) ->
    forall s n, P (ntimes n g) s.
  Admitted.
  *)

End Grammar.

Set Default Proof Mode "Ltac2".

Ltac2 split_alt c :=
  match! goal with
  | [ h :generates (alternative (char ?c0) _) _ |- _ ] =>
      let h := Control.hyp h in
      if Constr.equal (Std.eval_hnf c0) c then
        inversion $h
      else
        fail
  end.

Ltac2 split_digit () :=
  lazy_match! goal with
  | [ h : generates (char _) _ |- _ ] =>
      let h := Control.hyp h in
      inversion $h;
      reflexivity
  end.

Lemma digit_length_1 : forall s, generates digit s -> length s = 1.
Proof.
  intros.
  inversion H.

  (* probably this could be automated with Ltac2 but there are only so many
     hours in a day! *)
  split_digit ().
  split_alt '"1"%char.
  split_digit ().
  split_alt '"2"%char.
  split_digit ().
  split_alt '"3"%char.
  split_digit ().
  split_alt '"4"%char.
  split_digit ().
  split_alt '"5"%char.
  split_digit ().
  split_alt '"6"%char.
  split_digit ().
  split_alt '"7"%char.
  split_digit ().
  split_alt '"8"%char.
  split_digit ().
  split_alt '"9"%char.
  split_digit ().
  inversion H39.
Qed.

Set Default Proof Mode "Classic".

(** If `s` has length `n`, and is a sequence of zero or more digits, then it is
    a sequence of `n` digits. *)
Lemma ntimes_digits :
  forall n s,
  generates (star digit) s -> length s = n -> generates (ntimes n digit) s.
Admitted.

Lemma ToZeroPaddedDecimalString_2_digits :
  forall n nv h, (0 <= n <= 99)%Z ->
  generates (ntimes 2 digit) (ToZeroPaddedDecimalString n 2 nv h).
Proof.
  intros.
  unfold ToZeroPaddedDecimalString, StringPad.
Admitted.

Lemma ToZeroPaddedDecimalString_4_digits :
  forall n nv h, (0 <= n <= 9999)%Z ->
  generates (ntimes 4 digit) (ToZeroPaddedDecimalString n 4 nv h).
Admitted.
