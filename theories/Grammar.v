(* Defines regular "grammars" in terms of regular expressions. *)

From Ltac2 Require Import Ltac2 List Printf.
Set Default Proof Mode "Classic".

From Stdlib Require Import
  Ascii
  List
  Strings.String
  Setoid
  Program.Equality
  ZArith.
From Temporal Require Import StringUtil.
Open Scope string_scope.

(** A regular grammar *)
Inductive grammar :=
| nothing
| empty
| char (c : ascii)
| alternative (a b : grammar)
| sequence (a b : grammar)
| star (a : grammar).

(** `generates g s` is a proposition which states that the string `s` can be
    generated by the grammar `g` *)
Inductive generates : grammar -> string -> Prop :=
| gen_empty : generates empty EmptyString
| gen_char : forall c, generates (char c) (String c EmptyString)
| gen_alt_l : forall s a b, generates a s -> generates (alternative a b) s
| gen_alt_r : forall s a b, generates b s -> generates (alternative a b) s
| gen_seq : forall s0 s1 a b, generates a s0 -> generates b s1 -> generates (sequence a b) (s0 ++ s1)
| gen_star_l : forall a, generates (star a) EmptyString
| gen_star_r : forall s0 s1 a, generates a s0 -> generates (star a) s1 -> generates (star a) (s0 ++ s1).

Fixpoint ntimes (n : nat) (a : grammar) :=
  match n with
  | 0 => empty
  | S n' => sequence a (ntimes n' a)
  end.

Fixpoint seq (gs : list grammar) :=
  match gs with
  | nil => empty
  | g :: gs' => sequence g (seq gs')
  end.

Fixpoint alt (gs : list grammar) :=
  match gs with
  | nil => nothing
  | g :: gs' => alternative g (alt gs')
  end.

Definition maybe a := alternative empty a.

Definition digit : grammar :=
  alt (
    char "0" :: char "1" :: char "2" :: char "3" :: char "4" ::
    char "5" :: char "6" :: char "7" :: char "8" :: char "9" ::
    nil
  ).

Module Grammar.
  (* two grammars are equivalent if they generate the same strings *)
  Definition Equiv (a b : grammar) := forall s, generates a s <-> generates b s.

  Module Equiv.
    Lemma refl : reflexive grammar Equiv.
    Proof.
      unfold reflexive, Equiv.
      split; intros; assumption.
    Qed.

    Lemma symm : symmetric grammar Equiv.
    Proof.
      unfold symmetric, Equiv.
      split; apply H.
    Qed.

    Lemma trans : transitive grammar Equiv.
    Proof.
      unfold transitive, Equiv.
      split.
      - intros. apply H0. apply H. assumption.
      - intros. apply H. apply H0. assumption.
    Qed.

    Add Relation grammar Equiv
      reflexivity proved by refl
      symmetry proved by symm
      transitivity proved by trans
      as Equiv_rel.
  End Equiv.

  Lemma alternative_assoc :
    forall a b c,
    Equiv (alternative (alternative a b) c) (alternative a (alternative b c)).
  Proof.
    split.
    - intros.
      dependent induction H.
      + dependent induction H.
        apply gen_alt_l; assumption.
        apply gen_alt_r, gen_alt_l; assumption.
      + apply gen_alt_r, gen_alt_r; assumption.
    - intros.
      dependent induction H.
      + apply gen_alt_l, gen_alt_l; assumption.
      + dependent induction H.
        apply gen_alt_l, gen_alt_r; assumption.
        apply gen_alt_r; assumption.
  Qed.

  Lemma alternative_comm :
    forall a b, Equiv (alternative a b) (alternative b a).
  Proof.
    split.
    - intros.
      dependent induction H.
      + apply gen_alt_r.
        assumption.
      + apply gen_alt_l.
        assumption.
    - intros.
      dependent induction H.
      + apply gen_alt_r.
        assumption.
      + apply gen_alt_l.
        assumption.
  Qed.

  Lemma alternative_nothing : forall a, Equiv a (alternative a nothing).
  Proof.
    split.
    - intros.
      apply gen_alt_l.
      assumption.
    - intros.
      dependent induction H.
      + assumption.
      + inversion H.
  Qed.

  Lemma sequence_assoc :
    forall a b c,
    Equiv (sequence (sequence a b) c) (sequence a (sequence b c)).
  Proof.
    split.
    - intros.
      dependent induction H.
      dependent induction H.
      rewrite append_assoc.
      apply gen_seq.
      + assumption.
      + apply gen_seq; assumption.
    - intros.
      dependent induction H.
      dependent induction H0.
      rewrite <- append_assoc.
      apply gen_seq.
      + apply gen_seq; assumption.
      + assumption.
  Qed.

  Lemma sequence_empty_l : forall a, Equiv a (sequence empty a).
  Proof.
    split.
    - intros.
      rewrite <- append_empty_l.
      apply gen_seq.
      + constructor.
      + assumption.
    - intros.
      dependent induction H.
      dependent induction H.
      assumption.
  Qed.

  Lemma sequence_empty_r : forall a, Equiv a (sequence a empty).
  Proof.
    split.
    - intros.
      rewrite <- append_empty_r.
      apply gen_seq.
      + assumption.
      + constructor.
    - intros.
      dependent induction H.
      dependent induction H0.
      rewrite append_empty_r.
      assumption.
  Qed.

  Lemma sequence_nothing_l : forall a, Equiv nothing (sequence nothing a).
  Proof.
    split.
    - intros.
      inversion H.
    - intros.
      dependent induction H.
      inversion H.
  Qed.

  Lemma sequence_nothing_r : forall a, Equiv nothing (sequence a nothing).
  Proof.
    split.
    - intros.
      inversion H.
    - intros.
      dependent induction H.
      inversion H0.
  Qed.

  Lemma unfold_star : forall a, Equiv (star a) (maybe (sequence a (star a))).
  Proof.
    split.
    - intros.
      dependent induction H.
      + apply gen_alt_l.
        constructor.
      + apply gen_alt_r.
        apply gen_seq; assumption.
    - intros.
      dependent induction H; dependent induction H.
      + apply gen_star_l.
      + apply gen_star_r; assumption.
  Qed.

  Lemma sequence_alternative_distrib_l :
    forall a b c,
    Equiv (sequence a (alternative b c)) (alternative (sequence a b) (sequence a c)).
  Proof.
    split.
    - intros.
      dependent induction H.
      dependent induction H0.
      + apply gen_alt_l.
        apply gen_seq; assumption.
      + apply gen_alt_r.
        apply gen_seq; assumption.
    - intros.
      dependent induction H; dependent induction H.
      + apply gen_seq.
        assumption.
        apply gen_alt_l.
        assumption.
      + apply gen_seq.
        assumption.
        apply gen_alt_r.
        assumption.
  Qed.

  Lemma sequence_alternative_distrib_r :
    forall a b c,
    Equiv (sequence (alternative a b) c) (alternative (sequence a c) (sequence b c)).
  Proof.
    split.
    - intros.
      dependent induction H.
      dependent induction H.
      + apply gen_alt_l.
        apply gen_seq; assumption.
      + apply gen_alt_r.
        apply gen_seq; assumption.
    - intros.
      dependent induction H; dependent induction H.
      + apply gen_seq.
        apply gen_alt_l.
        assumption.
        assumption.
      + apply gen_seq.
        apply gen_alt_r.
        assumption.
        assumption.
  Qed.

  Lemma equiv_elim {g0 g1 s} :
    generates g0 s -> Equiv g0 g1 -> generates g1 s.
  Proof.
    intros.
    specialize (H0 s).
    apply H0.
    assumption.
  Qed.

  Lemma sequence_string :
    forall a s g0 g1,
    generates g0 (String a EmptyString) -> generates g1 s ->
    generates (sequence g0 g1) (String a s).
  Proof.
    intros.
    rewrite <- append_char_l.
    apply gen_seq; assumption.
  Qed.

  Fixpoint star_append :
    forall g s0 s1,
    generates (star g) s0 -> generates (star g) s1 ->
    generates (star g) (s0 ++ s1).
  Proof.
    intros.
    dependent induction H.
    - assumption.
    - apply unfold_star.
      apply gen_alt_r.
      rewrite append_assoc.
      apply gen_seq.
      + assumption.
      + apply star_append; assumption.
  Qed.
End Grammar.

Set Default Proof Mode "Ltac2".

(** Apply the given thunk to the first goal. *)
Ltac2 first f := Control.focus 1 1 f.

Ltac2 Notation "either" f(constr) g(constr) :=
  Control.plus (fun () => f) (fun _ex => g).

(** Applying a particular tactic by looping over the digit characters. *)
Ltac2 rec char_loop f cs :=
  match cs with
  | [] => ()
  | c :: cs' =>
      f c;
      char_loop f cs'
  end.

Ltac2 digits () :=
  '"0"%char :: '"1"%char :: '"2"%char :: '"3"%char :: '"4"%char :: '"5"%char ::
  '"6"%char :: '"7"%char :: '"8"%char :: '"9"%char :: [].

Ltac2 on_digits f := char_loop f (digits ()).

(** if we know a string to be generated by either a given character `c`, or
   something else, case split on that hypothesis *)
Ltac2 split_alt c :=
  match! goal with
  | [ h : generates (alternative (char ?c0) _) _ |- _ ] =>
      let h := Control.hyp h in
      if Constr.equal (Std.eval_hnf c0) c then
        inversion $h
      else
        fail
  end.

(** if we know a string to be generated by a particular character, then we can
   substitute that character for the string. *)
Ltac2 split_digit () :=
  lazy_match! goal with
  | [ h : generates (char _) _ |- _ ] =>
      let h := Control.hyp h in
      inversion $h;
      reflexivity
  end.

(** given hypotheses `s0 ++ s1 = String a s` and `generates (char c) s0`, we can
    can derive `a = c` and `s1 = s`. *)
Ltac2 rewrite_char () :=
  let apply_rewrite () :=
    lazy_match! goal with
    | [ h0 : ?_s0 ++ _ = String _ _, h1 : ?_c = ?_s0 |- _ ] =>
        let h1 := Control.hyp h1 in
        rewrite <- $h1 in $h0;
        let h0 := Control.hyp h0 in
        inversion $h0
    end
  in
  lazy_match! goal with
  | [ _h : ?_s0 ++ _ = String _ _, h : generates (char ?_c) ?_s0 |- _ ] =>
      let h := Control.hyp h in
      inversion $h as [];
      apply_rewrite ()
  end.

Ltac2 rewrite_string () :=
  lazy_match! goal with
  | [ h0 : generates (star digit) ?_s1,
      h1 : ?_s1 = ?_s
      |- generates (star digit) ?_s ] =>
    let h1 := Control.hyp h1 in
    rewrite $h1 in $h0;
    assumption
  end.

(** apply the appropriate constructor when proving 
    generates digit (String c "")` *)
Ltac2 construct_digit () :=
  let rec again cs :=
    match cs with
    | [] => Control.zero (Tactic_failure (Some (fprintf "not a digit!")))
    | _ :: cs' =>
      Control.plus
        (fun () => apply gen_alt_l, gen_char)
        (fun _ex => apply gen_alt_r; again cs')
    end
  in
  again (digits ()).

Lemma digit_length_1 : forall s, generates digit s -> length s = 1.
Proof.
  intros.
  inversion H.
  split_digit ().
  on_digits (fun c => try (split_alt c; first split_digit)).
  inversion H39.
Qed.

Lemma digit_char :
  forall a s,
  generates (star digit) (String a s) -> generates digit (String a EmptyString).
Proof.
  intros.
  inversion H as [].
  unfold digit in H0.
  simpl in H0.

  on_digits (fun c =>
    split_alt c;
    first (fun () => rewrite_char (); construct_digit ())
  ).

  inversion H43.
Qed.

Lemma digit_string :
  forall a s,
  generates (star digit) (String a s) -> generates (star digit) s.
Proof.
  intros.
  inversion H as [].
  unfold digit in H0.
  simpl in H0.

  on_digits (fun c =>
    split_alt c;
    Control.focus 1 1 (fun () => rewrite_char (); rewrite_string ())
  ).
  
  inversion H43.
Qed.

Lemma ntimes_append_char :
  forall n a s,
  generates digit (String a EmptyString) -> generates (ntimes n digit) s ->
  generates (ntimes (S n) digit) (String a s).
Proof.
  intros.
  rewrite <- append_char_l.
  apply gen_seq; assumption.
Qed.

(** If `s` has length `n`, and is a sequence of zero or more digits, then it is
    a sequence of `n` digits. *)
Fixpoint ntimes_digits :
  forall n s,
  generates (star digit) s -> length s = n -> generates (ntimes n digit) s.
Proof.
  refine open_constr:(
    fun n s h l =>
      match s as s' return (s = s' -> generates (ntimes n digit) s') with
      | EmptyString => fun H => _
      | String a s => fun H => _
      end eq_refl
  ).

  - rewrite H in l.
    rewrite <- l.
    constructor.
  
  - rewrite H in l.
    rewrite <- l.
    apply ntimes_append_char.
    + rewrite H in h.
      apply (digit_char _ _ h).
    + apply ntimes_digits.
      * rewrite H in h.
        apply (digit_string _ _ h).
      * reflexivity.
Qed.

Ltac2 decimal_digit () :=
  rewrite <- append_char_l;
  apply gen_star_r;
  Control.enter (fun () => orelse construct_digit (fun _ex => assumption)).

Lemma string_of_int_some_digits :
  forall n, (0 <= n)%Z ->
  generates
    (sequence digit (star digit))
    (DecimalString.NilEmpty.string_of_int (Z.to_int n)).
Admitted.

Lemma string_of_int_digits :
  forall n, (0 <= n)%Z ->
  generates (star digit) (DecimalString.NilEmpty.string_of_int (Z.to_int n)).
Proof.
  intros.
  unfold DecimalString.NilEmpty.string_of_int, Z.to_int.
  destruct n eqn: n_def.
  - apply Grammar.unfold_star.
    apply gen_alt_r.
    rewrite <- append_empty_r.
    apply gen_seq.
    + construct_digit ().
    + apply gen_star_l.
  - induction (Pos.to_uint p); simpl.
    apply gen_star_l.
    all: decimal_digit ().
  - destruct H.
    reflexivity.
Qed.

Lemma string_of_int_length_2 :
  forall n, (0 <= n <= 99)%Z ->
  length (DecimalString.NilEmpty.string_of_int (Z.to_int n)) <= 2.
Proof.
  intros.
  destruct H.
  unfold Z.to_int.
  destruct n eqn: n_def.
  - auto.
  - admit.
  - destruct H.
    reflexivity.
Admitted.

Lemma string_of_int_length_4 :
  forall n, (0 <= n <= 9999)%Z ->
  length (DecimalString.NilEmpty.string_of_int (Z.to_int n)) <= 4.
Proof.
  intros.
  destruct H.
  unfold Z.to_int.
  destruct n eqn: n_def.
  - auto.
  - admit.
  - destruct H.
    reflexivity.
Admitted.

Lemma Z_to_string_2_digits :
  forall n, (0 <= n <= 99)%Z -> length (Z_to_string n) <= 2.
Proof.
  now apply string_of_int_length_2.
Qed.

Lemma Z_to_string_4_digits :
  forall n, (0 <= n <= 9999)%Z -> length (Z_to_string n) <= 4.
Proof.
  now apply string_of_int_length_4.
Qed.

Lemma Z_to_string_some_digits :
  forall n, (0 <= n)%Z ->
  generates (sequence digit (star digit)) (Z_to_string n).
Proof.
  now apply string_of_int_some_digits.
Qed.

Lemma Z_to_string_digits :
  forall n, (0 <= n)%Z -> generates (star digit) (Z_to_string n).
Proof.
  intros.
  now apply string_of_int_digits.
Qed.

Lemma RepeatString_digits :
  forall n, generates (star digit) (RepeatString "0" n).
Proof.
  induction n.
  - constructor.
  - simpl.
    rewrite <- append_char_l.
    apply gen_star_r.
    + construct_digit ().
    + assumption.
Qed.

Lemma RepeatString_some_digits :
  forall n, 0 < n ->
  generates (sequence digit (star digit)) (RepeatString "0" n).
Proof.
  intros.
  destruct n.
  - auto with *.
  - simpl.
    rewrite <- append_char_l.
    apply gen_seq.
    + construct_digit ().
    + apply RepeatString_digits.
Qed.

Lemma length_nonnegative_z : forall s, (0 <= Z.of_nat (length s))%Z.
Proof.
  intros.
  now destruct s.
Qed.

Lemma ToZeroPaddedDecimalString_4_digits :
  forall n nv h, (0 <= n <= 9999)%Z ->
  generates (ntimes 4 digit) (ToZeroPaddedDecimalString n 4 nv h).
Proof.
  assert (z4 : 4%Z = Z.of_nat 4). { ltac1:(easy). }
  intros.
  unfold ToZeroPaddedDecimalString, StringPad.
  destruct ("0" =? EmptyString) eqn: h'. {
    rewrite eqb_eq in h'.
    discriminate.
  }
  destruct (4 <=? Z.of_nat (length (Z_to_string n)))%Z eqn: n_len.
  - unfold Z_to_string.
    apply ntimes_digits.
    + now apply string_of_int_digits.
    + rewrite Z.leb_le in n_len.
      rewrite z4 in n_len.
      rewrite <- Nat2Z.inj_le in n_len.
      apply Nat.le_antisymm.
      * apply string_of_int_length_4.
        assumption.
      * assumption.
  - apply ntimes_digits.
    + apply Grammar.star_append.
      * apply RepeatString_digits.
      * now apply Z_to_string_digits.
    + rewrite append_length.
      rewrite RepeatString_length.
      * rewrite z4.
        rewrite Z2Nat.inj_sub.
        rewrite Nat2Z.id, Nat2Z.id.
        apply Nat.sub_add.
        rewrite z4 in n_len.
        rewrite Z.leb_gt in n_len.
        rewrite Z2Nat.inj_lt in n_len.
        rewrite Nat2Z.id, Nat2Z.id in n_len.
        apply Nat.lt_le_incl.
        assumption.
        apply length_nonnegative_z.
        ltac1:(easy).
        apply length_nonnegative_z.
      * apply Nat.lt_0_1.
Qed.

Lemma ToZeroPaddedDecimalString_2_digits :
  forall n nv h, (0 <= n <= 99)%Z ->
  generates (ntimes 2 digit) (ToZeroPaddedDecimalString n 2 nv h).
Proof.
  intros.
  unfold ToZeroPaddedDecimalString, StringPad.
Proof.
  assert (z2 : 2%Z = Z.of_nat 2). { ltac1:(easy). }
  intros.
  unfold ToZeroPaddedDecimalString, StringPad.
  destruct ("0" =? EmptyString) eqn: h'. {
    rewrite eqb_eq in h'.
    discriminate.
  }
  destruct (2 <=? Z.of_nat (length (Z_to_string n)))%Z eqn: n_len.
  - unfold Z_to_string.
    apply ntimes_digits.
    + now apply string_of_int_digits.
    + rewrite Z.leb_le in n_len.
      rewrite z2 in n_len.
      rewrite <- Nat2Z.inj_le in n_len.
      apply Nat.le_antisymm.
      * apply string_of_int_length_2.
        assumption.
      * assumption.
  - apply ntimes_digits.
    + apply Grammar.star_append.
      * apply RepeatString_digits.
      * now apply Z_to_string_digits.
    + rewrite append_length.
      rewrite RepeatString_length.
      * rewrite z2.
        rewrite Z2Nat.inj_sub.
        rewrite Nat2Z.id, Nat2Z.id.
        apply Nat.sub_add.
        rewrite z2 in n_len.
        rewrite Z.leb_gt in n_len.
        rewrite Z2Nat.inj_lt in n_len.
        rewrite Nat2Z.id, Nat2Z.id in n_len.
        apply Nat.lt_le_incl.
        assumption.
        apply length_nonnegative_z.
        ltac1:(easy).
        apply length_nonnegative_z.
      * apply Nat.lt_0_1.
Qed.

Lemma ToZeroPaddedDecimalString_gt_0_digits :
  forall n m nv mv, (0 < m)%Z ->
  generates (sequence digit (star digit)) (ToZeroPaddedDecimalString n m nv mv).
Proof.
  intros.
  unfold ToZeroPaddedDecimalString, StringPad.
  destruct ("0" =? EmptyString) eqn: h'. {
    rewrite eqb_eq in h'.
    discriminate.
  }
  destruct (m <=? Z.of_nat (length (Z_to_string n)))%Z.
  - now apply Z_to_string_some_digits.
  - admit.
Admitted.
